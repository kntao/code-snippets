package com.xxx.xxx.query;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.HashSet;import java.util.Iterator;import java.util.Set;import java.util.concurrent.ConcurrentLinkedQueue;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;/* * 处理一级线程 * @author kongqingtao */public class HandleOnceFriendThread extends Thread{	private LinkedBlockingQueue<String> rawDataQueue; // 原数据队列	private LinkedBlockingQueue<String> onceFriendDataQueue; // 一级结果数据队列	private Set<String> set ; // 二级结果数据	private ConcurrentLinkedQueue<String> resultsQueue; // 最终数据	private CountDownLatch threadsSignal;	private ExecutorService  pool;	private  int threadCountL2 =Integer.parseInt(Factory.getSystemPropertiesValue("threadCountL2"));			public HandleOnceFriendThread(LinkedBlockingQueue<String> rawDataQueue,ExecutorService pool,ConcurrentLinkedQueue<String> resultsQueue){		this.rawDataQueue = rawDataQueue;		this.resultsQueue = resultsQueue;		this.pool = pool;				onceFriendDataQueue = new LinkedBlockingQueue<String>();		set = Collections.synchronizedSet(new HashSet<String>());			}		public void run(){		while(true){			if(!rawDataQueue.isEmpty()){				threadsSignal = new CountDownLatch(threadCountL2); // 信号量，等待二级处理返回结果。								String uid= rawDataQueue.poll();				if(uid != null){					System.out.printf("一级线程：%s处理原数据%s\n",Thread.currentThread().getName(),uid);					String onceFriends = FriendsHbaseAPI.queryByKey(uid);					String [] onceFriendArray = onceFriends.split(",");					onceFriendDataQueue.addAll(Arrays.asList(onceFriendArray));										for(int i = 0; i < threadCountL2; i++){						HandleTwiceFriendThread t = new HandleTwiceFriendThread(onceFriendDataQueue,set,threadsSignal); // 开启二级线程						t.setName("handleTwiceFriendThread" + i);						pool.execute(t);					}					try					{						threadsSignal.await(); // 一级线程等待					}					catch (InterruptedException e)					{						// TODO Auto-generated catch block						e.printStackTrace();					}									StringBuffer sb = new StringBuffer(uid); // 汇总处理结果					sb.append("|");					sb.append(onceFriends);					sb.append("|");					for (Iterator<String> it = set.iterator(); it.hasNext();)					{						sb.append(it.next().toString());						sb.append(",");					}					sb.deleteCharAt(sb.length()-1);					resultsQueue.add(sb.toString());					System.out.printf("%s结果处理完毕,其一度好友数：%s,二度好友数：%s\n",uid,onceFriendArray.length,set.size());					// 清理数据					onceFriendDataQueue.clear();					set.clear();					threadsSignal = null;				}			}			else{				try				{					Thread.sleep(1*1000);				}				catch (InterruptedException e)				{					// TODO Auto-generated catch block					e.printStackTrace();				}			}		}	}	/**	 * @param args	 */	public static void main(String[] args)	{		// TODO Auto-generated method stub	}}